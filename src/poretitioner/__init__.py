import pathlib
from typing import *  # I know people don't like import *, but I think it has benefits for types (doesn't impede people from being generous with typing)

from .fast5s import (
    BulkFile,
    CaptureFile,
    ContextTagsBase,
    ContextTagsBulk,
    ContextTagsCapture,
    SubRun,
)
from .getargs import ARG, get_help
from .logger import Logger, getLogger
from .signals import (
    Capture,
    CaptureMetadata,
    FractionalizedSignal,
    PicoampereSignal,
    RawSignal,
)
from .utils import classify as classify
from .utils import filtering as filtering
from .utils import segment as segmenter
from .utils.configuration import (
    CONFIG,
    GeneralConfiguration,
    PoretitionerConfig,
    SegmentConfiguration,
    readconfig,
)
from .utils.exceptions import (
    CaptureSchemaVersionException,
    HDF5GroupSerializationException,
    HDF5SerializationException,
    PluginNotFoundException,
)

# Exceptions


def default_config(
    default_file: str = "", with_command_line_args: Optional[Dict[str, str]] = None
) -> PoretitionerConfig:
    fallback_config_path = str(
        pathlib.Path("./DEFAULT_PORETITIONER_CONFIG.toml").absolute().resolve()
    )
    path_to_default_config = (
        default_file if len(default_file) > 0 else fallback_config_path
    )
    return readconfig(path_to_default_config, command_line_args=with_command_line_args)


def segment(
    config: GeneralConfiguration,
    segment_config: SegmentConfiguration,
    bulkfast5=None,  # Only needed if one wasn't passed in to segment config.
    save_location=None,
    overwrite=True,
    sub_run: SubRun = None,
) -> Iterable[CaptureFile]:
    """Identifies the capture regions in a nanopore ionic current signal.

    Parameters
    ----------
    bulk_f5_filepath : str
        Path to the bulk fast5 file, likely generated by the MinKnow software.
    save_location : str
        Directory to save the segmentation results (results will often be saved to more than one file).
    config : Dict
        Segmentaiotn configuration
    sub_run_start_observations : int, optional
        Where to start in the run (e.g. start segmenting after 10 observations). This is useful in cases
        where the run is continuous, but you added a different analyte or wash at some known point in time, by default 0
    sub_run_end_observations : int, optional
        Where to stop segmenting in the run (if anywhere). This is useful in cases
        where the run is continuous, but you added a different analyte or wash at some known point in time, by default None

    Returns
    ----------
    Iterable[CaptureFile]
        An iterable of capture files. This can be used like a list of the segmented captures.

    """
    if bulkfast5 is None:
        try:
            bulkfast5 = segment_config.bulkfast5
        except AttributeError:
            raise ValueError(
                "Please pass in a BulkFast5 filepath to perform segmentation, using either the bulkfast5= keyword argument, or adding it to the Segmenter section of the config file."
            )
    capture_files = segmenter.segment(
        segment_config.bulkfast5,
        config,
        segment_config,
        save_location=save_location,
        capture_criteria=segment_config.capture_criteria,
        overwrite=overwrite,
        sub_run=sub_run,
    )
    return capture_files
